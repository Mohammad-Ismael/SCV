#!/usr/bin/env python3
# generate_custom_data.py

import re
import sys
import os
import json

def parse_vtop_header(vtop_path):
    """Parse Vtop.h to extract input ports (excluding clk)"""
    with open(vtop_path, 'r') as f:
        content = f.read()

    # Match sc_in declarations (ignore clk)
    port_pattern = r'sc_core::sc_in<([^>]+)> &(\w+);'
    ports = []
    for match in re.finditer(port_pattern, content):
        data_type = match.group(1).strip()
        name = match.group(2)
        if name == 'clk':
            continue  # Skip clock
        ports.append({'name': name, 'type': data_type})
    return ports

def map_sc_type_to_custom_type(sc_type):
    """
    Map SystemC types to YOUR custom types (exactly as in your code)
    """
    # Your ALU uses: bool, uint32_t -> but you map uint32_t to int32_t in CustomData
    if sc_type == 'bool':
        return 'bool'
    elif sc_type in ['uint32_t', 'int32_t']:
        return 'int32_t'
    elif sc_type in ['uint16_t', 'int16_t']:
        return 'int16_t'
    elif sc_type in ['uint64_t', 'int64_t']:
        return 'int64_t'
    else:
        # Default to int32_t for unknown numeric types (safe for ALU)
        return 'int32_t'

def generate_custom_data_h(ports, output_path):
    """Generate custom_data.h EXACTLY matching your format"""
    
    # Build DECLARE_FIELD lines EXACTLY as in your code
    declare_lines = []
    for port in ports:
        custom_type = map_sc_type_to_custom_type(port['type'])
        declare_lines.append(f"    DECLARE_FIELD({port['name']}, {custom_type})")
    
    # Join with backslashes for macro
    define_fields = " \\\n".join(declare_lines)

    template = f"""// AUTO-GENERATED by generate_verification.py
// DO NOT EDIT MANUALLY
#ifndef CUSTOM_DATA_H
#define CUSTOM_DATA_H

#include <vector>
#include <cstring>
#include <ostream>
#include <map>
#include <string>
#include <typeindex>
#include <cstdint>
#include <cstdlib>
#include <limits>
#include "rand_const.h"

// Macro to define fields and generate get_fields()
#define DECLARE_FIELD(name, type) type name;
#define ADD_FIELD_TO_MAP(name, type) \\
    fields.emplace(#name, std::make_pair(offsetof(CustomData, name), std::type_index(typeid(type))));

// Define the input of the portlist here
#define DEFINE_CUSTOM_DATA_FIELDS \\
{define_fields}

struct CustomData
{{
    // Define fields using macro
    DEFINE_CUSTOM_DATA_FIELDS

    std::vector<unsigned char> serialize() const
    {{
        std::vector<unsigned char> buffer(sizeof(*this));
        std::memcpy(buffer.data(), this, sizeof(*this));
        return buffer;
    }}

    static CustomData deserialize(const unsigned char *buffer)
    {{
        CustomData data;
        std::memcpy(&data, buffer, sizeof(CustomData));
        return data;
    }}

    friend std::ostream &operator<<(std::ostream &os, const CustomData &data)
    {{
        os << "{{";
        bool first = true;
        auto fields = get_fields();
        for (const auto &field : fields)
        {{
            if (!first)
                os << ", ";
            os << field.first << "=";
            auto offset = field.second.first;
            auto type = field.second.second;

            if (type == std::type_index(typeid(int16_t)))
            {{
                os << *reinterpret_cast<const int16_t *>(reinterpret_cast<const char *>(&data) + offset);
            }}
            else if (type == std::type_index(typeid(int32_t)))
            {{
                os << *reinterpret_cast<const int32_t *>(reinterpret_cast<const char *>(&data) + offset);
            }}
            else if (type == std::type_index(typeid(int64_t)))
            {{
                os << *reinterpret_cast<const int64_t *>(reinterpret_cast<const char *>(&data) + offset);
            }}
            else if (type == std::type_index(typeid(__int128)))
            {{
                os << static_cast<int64_t>(*reinterpret_cast<const __int128 *>(reinterpret_cast<const char *>(&data) + offset));
            }}
            else if (type == std::type_index(typeid(bool)))
            {{
                os << (*reinterpret_cast<const bool *>(reinterpret_cast<const char *>(&data) + offset) ? "1" : "0");
            }}
            first = false;
        }}
        os << "}}";
        return os;
    }}

    static std::map<std::string, std::pair<size_t, std::type_index>> get_fields()
    {{
        std::map<std::string, std::pair<size_t, std::type_index>> fields;
        // Generate field mappings using macro
        DEFINE_CUSTOM_DATA_FIELDS
#undef DECLARE_FIELD
#define DECLARE_FIELD(name, type) ADD_FIELD_TO_MAP(name, type)
        DEFINE_CUSTOM_DATA_FIELDS
#undef DECLARE_FIELD
        return fields;
    }}

    static bool set_field(CustomData &data, const std::string &field_name, const std::string &value_str)
    {{
        auto fields = get_fields();
        auto it = fields.find(field_name);
        if (it == fields.end())
            return false;

        size_t offset = it->second.first;
        std::type_index type = it->second.second;

        // Handle "rand" first
        if (value_str == "\\"rand\\"" || value_str == "rand")
        {{
            double min_val = 0;
            double max_val = 0;

            if (type == std::type_index(typeid(int16_t)))
            {{
                min_val = std::numeric_limits<int16_t>::min();
                max_val = std::numeric_limits<int16_t>::max();
            }}
            else if (type == std::type_index(typeid(int32_t)))
            {{
                min_val = std::numeric_limits<int32_t>::min();
                max_val = std::numeric_limits<int32_t>::max();
            }}
            else if (type == std::type_index(typeid(int64_t)))
            {{
                min_val = std::numeric_limits<int64_t>::min();
                max_val = std::numeric_limits<int64_t>::max();
            }}
            else if (type == std::type_index(typeid(__int128)))
            {{
                min_val = static_cast<double>(std::numeric_limits<__int128>::min());
                max_val = static_cast<double>(std::numeric_limits<__int128>::max());
            }}
            else if (type == std::type_index(typeid(bool)))
            {{
                // For bool, rand means random true/false
                *reinterpret_cast<bool *>(reinterpret_cast<char *>(&data) + offset) = (std::rand() % 2 == 0);
                return true;
            }}

            // Apply constraints if available
            if (RandConstraints::constraints.find(field_name) != RandConstraints::constraints.end())
            {{
                min_val = RandConstraints::constraints.at(field_name).first;
                max_val = RandConstraints::constraints.at(field_name).second;
            }}

            long long range = static_cast<long long>(max_val - min_val + 1);
            long long rand_val = min_val + (std::rand() % range);

            if (type == std::type_index(typeid(int16_t)))
            {{
                *reinterpret_cast<int16_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int16_t>(rand_val);
            }}
            else if (type == std::type_index(typeid(int32_t)))
            {{
                *reinterpret_cast<int32_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int32_t>(rand_val);
            }}
            else if (type == std::type_index(typeid(int64_t)))
            {{
                *reinterpret_cast<int64_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int64_t>(rand_val);
            }}
            else if (type == std::type_index(typeid(__int128)))
            {{
                *reinterpret_cast<__int128 *>(reinterpret_cast<char *>(&data) + offset) = static_cast<__int128>(rand_val);
            }}
            return true;
        }}

        // Handle boolean values
        if (type == std::type_index(typeid(bool)))
        {{
            std::string value = value_str;
            // Remove surrounding quotes if present (e.g., "\\"true\\"" → "true")
            if (value.size() >= 2 && value.front() == '\\"' && value.back() == '\\"')
            {{
                value = value.substr(1, value.size() - 2);
            }}
            if (value == "true" || value == "1")
            {{
                *reinterpret_cast<bool *>(reinterpret_cast<char *>(&data) + offset) = true;
                return true;
            }}
            else if (value == "false" || value == "0")
            {{
                *reinterpret_cast<bool *>(reinterpret_cast<char *>(&data) + offset) = false;
                return true;
            }}
            return false; // Invalid boolean string
        }}

        // Handle numeric values
        try
        {{
            if (type == std::type_index(typeid(int16_t)))
            {{
                *reinterpret_cast<int16_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int16_t>(std::stoi(value_str));
            }}
            else if (type == std::type_index(typeid(int32_t)))
            {{
                *reinterpret_cast<int32_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int32_t>(std::stoll(value_str));
            }}
            else if (type == std::type_index(typeid(int64_t)))
            {{
                *reinterpret_cast<int64_t *>(reinterpret_cast<char *>(&data) + offset) = std::stoll(value_str);
            }}
            else if (type == std::type_index(typeid(__int128)))
            {{
                *reinterpret_cast<__int128 *>(reinterpret_cast<char *>(&data) + offset) = std::stoll(value_str);
            }}
            else
            {{
                return false; // Unsupported type
            }}
            return true;
        }}
        catch (...)
        {{
            return false;
        }}
    }}
}};

#endif // CUSTOM_DATA_H
"""
    
    with open(output_path, 'w') as f:
        f.write(template)
    print(f"✅ Generated {output_path}")

def generate_json_template(ports, output_path):
    """Generate a template JSON file with all ports in stimule directory"""
    # Define the stimule directory path
    stimule_dir = "stimule"
    
    # Create stimule directory if it doesn't exist
    if not os.path.exists(stimule_dir):
        os.makedirs(stimule_dir)
        print(f"📁 Created directory: {stimule_dir}")
    
    # Generate the full output path in stimule directory
    full_output_path = os.path.join(stimule_dir, output_path)
    
    template = {
        "tests": [
            {
                port['name']: "rand" if port['type'] != 'bool' else "true"
                for port in ports
            }
        ]
    }
    
    with open(full_output_path, 'w') as f:
        json.dump(template, f, indent=4)
    print(f"✅ Generated {full_output_path}")

if __name__ == "__main__":
    if len(sys.argv) != 4:
        print("Usage: python3 generate_custom_data.py <Vtop.h path> <custom_data.h output> <json_template.json output>")
        sys.exit(1)
    
    vtop_path = sys.argv[1]
    custom_data_path = sys.argv[2]
    json_path = sys.argv[3]
    
    if not os.path.exists(vtop_path):
        print(f"Error: {vtop_path} not found!")
        sys.exit(1)
    
    ports = parse_vtop_header(vtop_path)
    print(f"Found {len(ports)} input ports (excluding clk):")
    for p in ports:
        print(f"  - {p['name']} ({p['type']})")
    
    generate_custom_data_h(ports, custom_data_path)
    generate_json_template(ports, json_path)