#!/usr/bin/env python3
# generate_verification.py

import re
import sys
import os

def parse_vtop_header(vtop_path):
    """Parse Vtop.h to extract port list"""
    with open(vtop_path, 'r') as f:
        content = f.read()

    port_pattern = r'sc_core::sc_(in|out)<([^>]+)> &(\w+);'
    ports = []
    for match in re.finditer(port_pattern, content):
        direction = match.group(1)
        data_type = match.group(2).strip()
        name = match.group(3)
        ports.append({
            'name': name,
            'type': data_type,
            'direction': direction
        })
    return ports

def map_to_comparator_type(rtl_type):
    """Map RTL output type to comparator type"""
    if '64' in rtl_type:
        return 'int64_t'
    elif '32' in rtl_type or 'uint' in rtl_type:
        return 'int32_t'
    elif '16' in rtl_type:
        return 'int16_t'
    elif '8' in rtl_type:
        return 'int8_t'
    else:
        return 'int32_t'

def generate_output_struct(output_ports, output_path):
    """Generate output_struct.h with EXACT RTL output types"""
    if not output_ports:
        # Fallback to single output (shouldn't happen in practice)
        struct_def = """struct OutputStruct {
    int32_t value;
};"""
    else:
        # Use EXACT RTL types - no mapping/conversion!
        comp_fields = []
        for port in output_ports:
            # Use the original RTL type exactly as defined
            comp_fields.append(f"    {port['type']} {port['name']};")
        
        struct_def = f"""struct OutputStruct {{
{chr(10).join(comp_fields)}
}};"""
    
    template = f"""// AUTO-GENERATED by generate_verification.py
// DO NOT EDIT MANUALLY

#ifndef OUTPUT_STRUCT_H
#define OUTPUT_STRUCT_H

{struct_def}

#endif // OUTPUT_STRUCT_H
"""
    
    with open(output_path, 'w') as f:
        f.write(template)
    print(f"✅ Generated {output_path}")
def generate_transactor(ports, output_path):
    """Generate transactor.h that sends ALL outputs to comparator"""
    inputs = [p for p in ports if p['direction'] == 'in' and p['name'] != 'clk']
    outputs = [p for p in ports if p['direction'] == 'out']
    
    signal_decls = []
    for port in inputs + outputs:
        signal_decls.append(f"    sc_core::sc_signal<{port['type']}> {port['name']}_sig;")
    
    rtl_connections = []
    for port in ports:
        if port['name'] == 'clk':
            rtl_connections.append("        rtl->clk(tc->clk);")
        else:
            rtl_connections.append(f"        rtl-> {port['name']}({port['name']}_sig);")
    
    drive_inputs = []
    for port in inputs:
        drive_inputs.append(f"            {port['name']}_sig.write(static_cast<{port['type']}>(data.{port['name']}));")
    
    read_outputs = []
    for port in outputs:
        read_outputs.append(f"            {port['type']} {port['name']} = {port['name']}_sig.read();")
    
    print_outputs = []
    for port in outputs:
        print_outputs.append(f'                          << " | {port["name"]} = " << {port["name"]}')
    
    output_struct_assignments = []
    for port in outputs:
        comp_type = map_to_comparator_type(port['type'])
        output_struct_assignments.append(f"    output.{port['name']} = static_cast<{comp_type}>({port['name']});")
    
    send_to_comparator = ""
    if outputs:
        send_to_comparator = f"""        // Send all outputs to comparator
        OutputStruct output;
{chr(10).join(output_struct_assignments)}
        send_to_comparator(output);"""
    
    template = f"""// AUTO-GENERATED by generate_verification.py
// DO NOT EDIT MANUALLY

#ifndef TRANSACTOR_H
#define TRANSACTOR_H

#include <systemc>
#include <tlm>
#include <tlm_utils/simple_target_socket.h>
#include <iostream>  //
#include "custom_data.h"
#include "debug.h"
#include "verilated/obj_dir/Vtop.h"
#include "timing_controller.h"
#include "comparator.h"
#include "output_struct.h"

using namespace std;  //
using namespace sc_core;

SC_MODULE(Transactor)
{{
    tlm_utils::simple_target_socket<Transactor> socket;
    tlm_utils::simple_initiator_socket<Transactor> socket_comparator;
    Vtop* rtl = nullptr;
    TimingController* tc = nullptr;

    // Auto-generated signals
{chr(10).join(signal_decls)}

    SC_CTOR(Transactor) : socket_comparator("socket_comparator")
    {{
        socket.register_b_transport(this, &Transactor::b_transport);
    }}

    void set_timing_controller(TimingController* controller) {{
        if (tc != nullptr) {{
            SC_REPORT_ERROR("Transactor", "Timing controller already set!");
            return;
        }}
        tc = controller;
        rtl = new Vtop("rtl");
{chr(10).join(rtl_connections)}
    }}

    void b_transport(tlm::tlm_generic_payload& trans, sc_core::sc_time& delay)
    {{
        if (trans.get_command() == tlm::TLM_WRITE_COMMAND)
        {{
            if (rtl == nullptr) {{
                SC_REPORT_ERROR("Transactor", "RTL not initialized!");
                return;
            }}

            auto data = CustomData::deserialize(trans.get_data_ptr());
{chr(10).join(drive_inputs)}

            if constexpr (DEBUG_TLM) {{
                cout << "\\n\\033[1;31mIIIII===================  Inside Transactor  ====================IIIII\\033[0m" << endl;
                std::cout << "\\033[1;31m"
                          << sc_time_stamp()
                          << " | Transactor | TLM | Driving RTL..."
                          << data
                          << "\\033[0m" << endl;
            }}

            tc->inputs_ready_event.notify();
            wait(tc->outputs_ready_event);
{chr(10).join(read_outputs)}
{send_to_comparator}

            if constexpr (DEBUG_RTL) {{
                std::cout << "\\033[1;31m"
                          << sc_time_stamp()
                          << " | Transactor | RTL Outputs:"{''.join(print_outputs)}
                          << "\\033[0m" << std::endl;
                std::cout << "\\033[1;31mIIIII===================  RTL Process Completed  ====================IIIII\\033[0m\\n"
                     << std::endl;
            }}
        }}
        trans.set_response_status(tlm::TLM_OK_RESPONSE);
    }}

    void send_to_comparator(const OutputStruct& output)
    {{
        tlm_generic_payload trans;
        sc_time delay = SC_ZERO_TIME;
        trans.set_data_ptr(reinterpret_cast<unsigned char*>(const_cast<OutputStruct*>(&output)));
        trans.set_data_length(sizeof(OutputStruct));
        trans.set_command(TLM_WRITE_COMMAND);
        trans.set_response_status(TLM_INCOMPLETE_RESPONSE);
        socket_comparator->b_transport(trans, delay);
    }}

    ~Transactor() {{
        delete rtl;
    }}
}};

#endif // TRANSACTOR_H
"""
    
    with open(output_path, 'w') as f:
        f.write(template)
    print(f"✅ Generated {output_path}")

def generate_comparator(output_ports, output_path):
    """Generate comparator.h with 100% dynamic coverage for any RTL module"""
    
    # Generate coverage declarations and update logic (100% dynamic)
    coverage_declarations = []
    coverage_update = []
    
    if output_ports:
        for port in output_ports:
            name = port['name']
            coverage_declarations.append(f"    std::map<int64_t, int> cp_{name}_bins;")
            coverage_declarations.append(f"    std::set<int64_t> cp_{name}_unique_values;")
            coverage_update.append(f"                cp_{name}_bins[static_cast<int64_t>(rtl_result.output.{name})]++;")
            coverage_update.append(f"                cp_{name}_unique_values.insert(static_cast<int64_t>(rtl_result.output.{name}));")
    
    # Generate cross-coverage (100% dynamic)
    cross_coverage = ""
    cross_update_code = ""
    cross_names = []
    
    if len(output_ports) >= 2:
        cross_declarations = []
        cross_updates = []
        
        for i in range(len(output_ports)):
            for j in range(i+1, len(output_ports)):
                port1_name = output_ports[i]['name']
                port2_name = output_ports[j]['name']
                safe_port1 = port1_name.replace('_', 'U')
                safe_port2 = port2_name.replace('_', 'U')
                cross_name = f"{safe_port1}_{safe_port2}"
                cross_names.append((port1_name, port2_name, cross_name))
                
                cross_declarations.append(f"    std::map<std::pair<int64_t, int64_t>, int> cp_cross_{cross_name};")
                cross_updates.append(f"                cp_cross_{cross_name}[{{static_cast<int64_t>(rtl_result.output.{port1_name}), static_cast<int64_t>(rtl_result.output.{port2_name})}}]++;")
        
        if cross_declarations:
            cross_coverage = "\n".join(cross_declarations)
            cross_update_code = "\n".join(cross_updates)
    
    # Generate C++ code for coverage calculation and reporting (100% dynamic)
    coverage_calc_and_report = ""
    if output_ports or cross_names:
        coverage_calc_and_report = """
            // Calculate total coverage percentage
            int total_coverage_points = 0;
            int covered_points = 0;
"""
        # Add bin coverage points
        for port in output_ports:
            name = port['name']
            coverage_calc_and_report += f"""            total_coverage_points += passed_tests;  // One point per test per signal
            covered_points += cp_{name}_unique_values.size();
"""
        
        # Add cross coverage points
        for port1, port2, cross_name in cross_names:
            coverage_calc_and_report += f"""            total_coverage_points += passed_tests;  // One point per test per cross
            covered_points += cp_cross_{cross_name}.size();
"""
        
        coverage_calc_and_report += """
            double total_coverage_pct = (total_coverage_points > 0) ? (covered_points * 100.0 / total_coverage_points) : 0.0;
            if (total_coverage_pct > 100.0) total_coverage_pct = 100.0;
            
            // Generate terminal summary
            std::cout << "\\033[1;35mTotal Functional Coverage: " 
                      << std::fixed << std::setprecision(1) << total_coverage_pct << "%\\033[0m" << std::endl;
            std::cout << "Tests: " << passed_tests << " passed, " << failed_tests << " failed (" 
                      << (test_count > 0 ? (passed_tests * 100.0 / test_count) : 0.0) << "% pass rate)" << std::endl;
            
            // Write detailed report to coverage_report.log
            std::ofstream log_file("coverage_report.log");
            if (log_file.is_open()) {
                log_file << "========================================" << std::endl;
                log_file << "         DETAILED COVERAGE REPORT" << std::endl;
                log_file << "========================================" << std::endl;
                log_file << "Coverage Summary:" << std::endl;
                log_file << "  Total Coverage: " << std::fixed << std::setprecision(1) << total_coverage_pct << "%" << std::endl;
                log_file << "Tests Summary:" << std::endl;
                log_file << "  Total Tests: " << test_count << std::endl;
                log_file << "  Passed: " << passed_tests << std::endl;
                log_file << "  Failed: " << failed_tests << std::endl;
                log_file << "  Pass Rate: " << (test_count > 0 ? (passed_tests * 100.0 / test_count) : 0.0) << "%" << std::endl;
                log_file << std::endl;
                
                // Detailed coverage per signal
"""
        for port in output_ports:
            name = port['name']
            coverage_calc_and_report += f"""                log_file << "=== SIGNAL: {name.upper()} ===" << std::endl;
                log_file << "Unique Values: " << cp_{name}_unique_values.size() << std::endl;
                log_file << "Hit Bins: " << cp_{name}_bins.size() << std::endl;
                double cov_{name}_pct = (passed_tests > 0) ? (cp_{name}_unique_values.size() * 100.0 / passed_tests) : 0.0;
                if (cov_{name}_pct > 100.0) cov_{name}_pct = 100.0;
                log_file << "Coverage: " << std::fixed << std::setprecision(1) << cov_{name}_pct << "%" << std::endl;
                // Top values
                std::vector<std::pair<int64_t, int>> sorted_{name}(cp_{name}_bins.begin(), cp_{name}_bins.end());
                std::sort(sorted_{name}.begin(), sorted_{name}.end(), 
                         [](const std::pair<int64_t, int>& a, const std::pair<int64_t, int>& b) {{
                             return a.second > b.second;
                         }});
                log_file << "Top 3 Values: ";
                for (int i = 0; i < std::min(3, (int)sorted_{name}.size()); i++) {{
                    log_file << sorted_{name}[i].first << "(" << sorted_{name}[i].second << ") ";
                }}
                log_file << std::endl << std::endl;
"""
        
        # Cross coverage details
        if cross_names:
            coverage_calc_and_report += """                log_file << "=== CROSS COVERAGE ===" << std::endl;
"""
            for port1, port2, cross_name in cross_names:
                coverage_calc_and_report += f"""                double cov_cross_{cross_name}_pct = (passed_tests > 0) ? (cp_cross_{cross_name}.size() * 100.0 / passed_tests) : 0.0;
                if (cov_cross_{cross_name}_pct > 100.0) cov_cross_{cross_name}_pct = 100.0;
                log_file << "Cross {port1} x {port2}: " << std::fixed << std::setprecision(1) << cov_cross_{cross_name}_pct << "%" << std::endl;
                log_file << "  Unique Combinations: " << cp_cross_{cross_name}.size() << std::endl << std::endl;
"""
        
        coverage_calc_and_report += """
                log_file << "========================================" << std::endl;
                log_file.close();
                std::cout << "\\033[1;35m📋 Detailed coverage report written to coverage_report.log\\033[0m" << std::endl;
            }
"""
    else:
        # No outputs - just show test summary
        coverage_calc_and_report = """
            std::cout << "\\033[1;35mTotal Functional Coverage: 0.0%\\033[0m" << std::endl;
            std::cout << "Tests: " << passed_tests << " passed, " << failed_tests << " failed (" 
                      << (test_count > 0 ? (passed_tests * 100.0 / test_count) : 0.0) << "% pass rate)" << std::endl;
"""
    
    template = f"""// AUTO-GENERATED by generate_verification.py
// DO NOT EDIT MANUALLY

#ifndef COMPARATOR_H
#define COMPARATOR_H

#include <systemc>
#include <tlm>
#include <tlm_utils/simple_target_socket.h>
#include <map>
#include <set>
#include <vector>
#include <algorithm>
#include <string>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <cstdint>
#include "debug.h"
#include "output_struct.h"

using namespace sc_core;
using namespace tlm;
using namespace tlm_utils;

SC_MODULE(Comparator)
{{
    simple_target_socket<Comparator> socket_rm;
    simple_target_socket<Comparator> socket_rtl;

    struct Result {{
        OutputStruct output;
        bool valid = false;
    }};
    
    Result rm_result;
    Result rtl_result;
    int test_count = 0;
    int passed_tests = 0;
    int failed_tests = 0;

    // Coverage data (100% dynamic - generated from Vtop.h)
{chr(10).join(coverage_declarations) if coverage_declarations else '    // No output ports'}

    // Cross coverage (100% dynamic)
{cross_coverage}

public:
    SC_CTOR(Comparator) 
        : socket_rm("socket_rm"), socket_rtl("socket_rtl")
    {{
        socket_rm.register_b_transport(this, &Comparator::b_transport_rm);
        socket_rtl.register_b_transport(this, &Comparator::b_transport_rtl);
    }}

    void b_transport_rm(tlm_generic_payload& trans, sc_time& delay)
    {{
        if (trans.get_command() == TLM_WRITE_COMMAND) {{
            auto* data = reinterpret_cast<OutputStruct*>(trans.get_data_ptr());
            rm_result.output = *data;
            rm_result.valid = true;
            check_and_compare();
        }}
        trans.set_response_status(TLM_OK_RESPONSE);
    }}

    void b_transport_rtl(tlm_generic_payload& trans, sc_time& delay)
    {{
        if (trans.get_command() == TLM_WRITE_COMMAND) {{
            auto* data = reinterpret_cast<OutputStruct*>(trans.get_data_ptr());
            rtl_result.output = *data;
            rtl_result.valid = true;
            check_and_compare();
        }}
        trans.set_response_status(TLM_OK_RESPONSE);
    }}

    void check_and_compare()
    {{
        if (rm_result.valid && rtl_result.valid) {{
            test_count++;
            bool match = true;
"""
    
    # Add comparison logic (100% dynamic from Vtop.h)
    if output_ports:
        comp_checks = []
        for port in output_ports:
            comp_checks.append(f"            if (rm_result.output.{port['name']} != rtl_result.output.{port['name']}) match = false;")
        template += "\n".join(comp_checks)
    else:
        template += "            if (rm_result.output.value != rtl_result.output.value) match = false;"
    
    # Add debug output (100% dynamic)
    debug_output = ""
    if output_ports:
        debug_fields_rm = []
        debug_fields_rtl = []
        for port in output_ports:
            debug_fields_rm.append(f"\"{port['name']}=\" << rm_result.output.{port['name']}")
            debug_fields_rtl.append(f"\"{port['name']}=\" << rtl_result.output.{port['name']}")
        rm_output = " << \", \" << ".join(debug_fields_rm)
        rtl_output = " << \", \" << ".join(debug_fields_rtl)
        debug_output = f"""
            if constexpr (DEBUG_CHECK_OUTPUTS) {{
                std::cout << "\\033[1;36m🔍 Test " << test_count << " Output Comparison:\\033[0m" << std::endl;
                std::cout << "   RM:  " << {rm_output} << std::endl;
                std::cout << "   RTL: " << {rtl_output} << std::endl;
            }}
"""
    else:
        debug_output = f"""
            if constexpr (DEBUG_CHECK_OUTPUTS) {{
                std::cout << "\\033[1;36m🔍 Test " << test_count << " Output Comparison:\\033[0m" << std::endl;
                std::cout << "   RM:  " << rm_result.output.value << std::endl;
                std::cout << "   RTL: " << rtl_result.output.value << std::endl;
            }}
"""
    
    template += debug_output + f"""
            if (match) {{
                std::cout << "\\033[1;32m✅ Test " << test_count << " PASSED\\033[0m" << std::endl;
                passed_tests++;
                if constexpr (DEBUG_COVERAGE) {{
{chr(10).join(['                ' + line for line in coverage_update]) if coverage_update else ''}
{cross_update_code}
                }}
            }} else {{
                std::cout << "\\033[1;31m❌ Test " << test_count << " FAILED\\033[0m" << std::endl;
                failed_tests++;
                // SC_REPORT_ERROR("Comparator", "RM and RTL outputs mismatch!");
            }}
            rm_result.valid = false;
            rtl_result.valid = false;
        }}
    }}
    
    ~Comparator() {{
        if constexpr (DEBUG_COVERAGE) {{
{coverage_calc_and_report}
        }}
    }}
}};

#endif // COMPARATOR_H
"""
    
    with open(output_path, 'w') as f:
        f.write(template)
    print(f"✅ Generated {output_path}")

if __name__ == "__main__":
    if len(sys.argv) != 5:
        print("Usage: python3 generate_verification.py <Vtop.h path> <transactor.h> <comparator.h> <output_struct.h>")
        sys.exit(1)
    
    vtop_path = sys.argv[1]
    transactor_path = sys.argv[2]
    comparator_path = sys.argv[3]
    output_struct_path = sys.argv[4]
    
    if not os.path.exists(vtop_path):
        print(f"Error: {vtop_path} not found!")
        sys.exit(1)
    
    ports = parse_vtop_header(vtop_path)
    inputs = [p for p in ports if p['direction'] == 'in' and p['name'] != 'clk']
    outputs = [p for p in ports if p['direction'] == 'out']
    
    print(f"Found {len(ports)} ports:")
    for p in ports:
        print(f"  - {p['name']} ({p['type']}) [{p['direction']}]")
    
    generate_output_struct(outputs, output_struct_path)
    generate_transactor(ports, transactor_path)
    generate_comparator(outputs, comparator_path)