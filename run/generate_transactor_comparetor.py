#!/usr/bin/env python3
# generate_verification.py

import re
import sys
import os

def parse_vtop_header(vtop_path):
    """Parse Vtop.h to extract port list"""
    with open(vtop_path, 'r') as f:
        content = f.read()

    port_pattern = r'sc_core::sc_(in|out)<([^>]+)> &(\w+);'
    ports = []
    for match in re.finditer(port_pattern, content):
        direction = match.group(1)
        data_type = match.group(2).strip()
        name = match.group(3)
        ports.append({
            'name': name,
            'type': data_type,
            'direction': direction
        })
    return ports

def map_to_comparator_type(rtl_type):
    """Map RTL output type to comparator type"""
    if '64' in rtl_type:
        return 'int64_t'
    elif '32' in rtl_type or 'uint' in rtl_type:
        return 'int32_t'
    elif '16' in rtl_type:
        return 'int16_t'
    elif '8' in rtl_type:
        return 'int8_t'
    else:
        return 'int32_t'

def generate_output_struct(output_ports, output_path):
    """Generate output_struct.h with OutputStruct definition"""
    if not output_ports:
        comp_type = "int32_t"
        struct_def = f"""struct OutputStruct {{
    {comp_type} value;
}};"""
    else:
        comp_fields = []
        for port in output_ports:
            comp_type = map_to_comparator_type(port['type'])
            comp_fields.append(f"    {comp_type} {port['name']};")
        
        struct_def = f"""struct OutputStruct {{
{chr(10).join(comp_fields)}
}};"""
    
    template = f"""// AUTO-GENERATED by generate_verification.py
// DO NOT EDIT MANUALLY

#ifndef OUTPUT_STRUCT_H
#define OUTPUT_STRUCT_H

{struct_def}

#endif // OUTPUT_STRUCT_H
"""
    
    with open(output_path, 'w') as f:
        f.write(template)
    print(f"✅ Generated {output_path}")

def generate_transactor(ports, output_path):
    """Generate transactor.h that sends ALL outputs to comparator"""
    inputs = [p for p in ports if p['direction'] == 'in' and p['name'] != 'clk']
    outputs = [p for p in ports if p['direction'] == 'out']
    
    signal_decls = []
    for port in inputs + outputs:
        signal_decls.append(f"    sc_core::sc_signal<{port['type']}> {port['name']}_sig;")
    
    rtl_connections = []
    for port in ports:
        if port['name'] == 'clk':
            rtl_connections.append("        rtl->clk(tc->clk);")
        else:
            rtl_connections.append(f"        rtl-> {port['name']}({port['name']}_sig);")
    
    drive_inputs = []
    for port in inputs:
        if port['name'] == 'rst_n':
            drive_inputs.append(f"            {port['name']}_sig.write(static_cast<{port['type']}>(data.rst_n));")
        else:
            drive_inputs.append(f"            {port['name']}_sig.write(static_cast<{port['type']}>(data.{port['name']}));")
    
    read_outputs = []
    for port in outputs:
        read_outputs.append(f"            {port['type']} {port['name']} = {port['name']}_sig.read();")
    
    print_outputs = []
    for port in outputs:
        print_outputs.append(f'                          << " | {port["name"]} = " << {port["name"]}')
    
    output_struct_assignments = []
    for port in outputs:
        comp_type = map_to_comparator_type(port['type'])
        output_struct_assignments.append(f"    output.{port['name']} = static_cast<{comp_type}>({port['name']});")
    
    send_to_comparator = ""
    if outputs:
        send_to_comparator = f"""        // Send all outputs to comparator
        OutputStruct output;
{chr(10).join(output_struct_assignments)}
        send_to_comparator(output);"""
    
    template = f"""// AUTO-GENERATED by generate_verification.py
// DO NOT EDIT MANUALLY

#ifndef TRANSACTOR_H
#define TRANSACTOR_H

#include <systemc>
#include <tlm>
#include <tlm_utils/simple_target_socket.h>
#include "custom_data.h"
#include "debug.h"
#include "verilated/obj_dir/Vtop.h"
#include "timing_controller.h"
#include "comparator.h"
#include "output_struct.h"

using namespace sc_core;

SC_MODULE(Transactor)
{{
    tlm_utils::simple_target_socket<Transactor> socket;
    tlm_utils::simple_initiator_socket<Transactor> socket_comparator;
    Vtop* rtl = nullptr;
    TimingController* tc = nullptr;

    // Auto-generated signals
{chr(10).join(signal_decls)}

    SC_CTOR(Transactor) : socket_comparator("socket_comparator")
    {{
        socket.register_b_transport(this, &Transactor::b_transport);
    }}

    void set_timing_controller(TimingController* controller) {{
        if (tc != nullptr) {{
            SC_REPORT_ERROR("Transactor", "Timing controller already set!");
            return;
        }}
        tc = controller;
        rtl = new Vtop("rtl");
{chr(10).join(rtl_connections)}
    }}

    void b_transport(tlm::tlm_generic_payload& trans, sc_core::sc_time& delay)
    {{
        if (trans.get_command() == tlm::TLM_WRITE_COMMAND)
        {{
            if (rtl == nullptr) {{
                SC_REPORT_ERROR("Transactor", "RTL not initialized!");
                return;
            }}

            auto data = CustomData::deserialize(trans.get_data_ptr());
{chr(10).join(drive_inputs)}

            if constexpr (DEBUG_TLM) {{
                cout << "\\n\\033[1;31mIIIII===================  Inside Transactor  ====================IIIII\\033[0m" << endl;
                std::cout << "\\033[1;31m"
                          << sc_time_stamp()
                          << " | Transactor | TLM | Driving RTL..."
                          << data
                          << "\\033[0m" << endl;
            }}

            tc->inputs_ready_event.notify();
            wait(tc->outputs_ready_event);
{chr(10).join(read_outputs)}
{send_to_comparator}

            if constexpr (DEBUG_RTL) {{
                std::cout << "\\033[1;31m"
                          << sc_time_stamp()
                          << " | Transactor | RTL Outputs:"{''.join(print_outputs)}
                          << "\\033[0m" << endl;
                cout << "\\033[1;31mIIIII===================  RTL Process Completed  ====================IIIII\\033[0m\\n"
                     << endl;
            }}
        }}
        trans.set_response_status(tlm::TLM_OK_RESPONSE);
    }}

    void send_to_comparator(const OutputStruct& output)
    {{
        tlm_generic_payload trans;
        sc_time delay = SC_ZERO_TIME;
        trans.set_data_ptr(reinterpret_cast<unsigned char*>(const_cast<OutputStruct*>(&output)));
        trans.set_data_length(sizeof(OutputStruct));
        trans.set_command(TLM_WRITE_COMMAND);
        trans.set_response_status(TLM_INCOMPLETE_RESPONSE);
        socket_comparator->b_transport(trans, delay);
    }}

    ~Transactor() {{
        delete rtl;
    }}
}};

#endif // TRANSACTOR_H
"""
    
    with open(output_path, 'w') as f:
        f.write(template)
    print(f"✅ Generated {output_path}")

def generate_comparator(output_ports, output_path):
    """Generate comparator.h with DEBUG_CHECK_OUTPUTS support"""
    template = f"""// AUTO-GENERATED by generate_verification.py
// DO NOT EDIT MANUALLY

#ifndef COMPARATOR_H
#define COMPARATOR_H

#include <systemc>
#include <tlm>
#include <tlm_utils/simple_target_socket.h>
#include "debug.h"
#include "output_struct.h"

using namespace sc_core;
using namespace tlm;
using namespace tlm_utils;

SC_MODULE(Comparator)
{{
    simple_target_socket<Comparator> socket_rm;
    simple_target_socket<Comparator> socket_rtl;

    struct Result {{
        OutputStruct output;
        bool valid = false;
    }};
    
    Result rm_result;
    Result rtl_result;
    int test_count = 0;

    SC_CTOR(Comparator) 
        : socket_rm("socket_rm"), socket_rtl("socket_rtl")
    {{
        socket_rm.register_b_transport(this, &Comparator::b_transport_rm);
        socket_rtl.register_b_transport(this, &Comparator::b_transport_rtl);
    }}

    void b_transport_rm(tlm_generic_payload& trans, sc_time& delay)
    {{
        if (trans.get_command() == TLM_WRITE_COMMAND) {{
            auto* data = reinterpret_cast<OutputStruct*>(trans.get_data_ptr());
            rm_result.output = *data;
            rm_result.valid = true;
            check_and_compare();
        }}
        trans.set_response_status(TLM_OK_RESPONSE);
    }}

    void b_transport_rtl(tlm_generic_payload& trans, sc_time& delay)
    {{
        if (trans.get_command() == TLM_WRITE_COMMAND) {{
            auto* data = reinterpret_cast<OutputStruct*>(trans.get_data_ptr());
            rtl_result.output = *data;
            rtl_result.valid = true;
            check_and_compare();
        }}
        trans.set_response_status(TLM_OK_RESPONSE);
    }}

    void check_and_compare()
    {{
        if (rm_result.valid && rtl_result.valid) {{
            test_count++;
            // Compare all fields dynamically
            bool match = true;
"""
    
    # Add comparison logic
    if output_ports:
        comp_checks = []
        for port in output_ports:
            comp_checks.append(f"            if (rm_result.output.{port['name']} != rtl_result.output.{port['name']}) match = false;")
        template += "\n".join(comp_checks)
    else:
        template += "            if (rm_result.output.value != rtl_result.output.value) match = false;"
    
    # Add debug output for all fields
    debug_output = ""
    if output_ports:
        debug_fields_rm = []
        debug_fields_rtl = []
        for port in output_ports:
            debug_fields_rm.append(f"\"{port['name']}=\" << rm_result.output.{port['name']}")
            debug_fields_rtl.append(f"\"{port['name']}=\" << rtl_result.output.{port['name']}")
        rm_output = " << \", \" << ".join(debug_fields_rm)
        rtl_output = " << \", \" << ".join(debug_fields_rtl)
        debug_output = f"""
            if constexpr (DEBUG_CHECK_OUTPUTS) {{
                std::cout << "\\033[1;36m🔍 Test " << test_count << " Output Comparison:\\033[0m" << std::endl;
                std::cout << "   RM:  " << {rm_output} << std::endl;
                std::cout << "   RTL: " << {rtl_output} << std::endl;
            }}
"""
    else:
        debug_output = f"""
            if constexpr (DEBUG_CHECK_OUTPUTS) {{
                std::cout << "\\033[1;36m🔍 Test " << test_count << " Output Comparison:\\033[0m" << std::endl;
                std::cout << "   RM:  " << rm_result.output.value << std::endl;
                std::cout << "   RTL: " << rtl_result.output.value << std::endl;
            }}
"""
    
    template += debug_output + f"""
            if (match) {{
                std::cout << "\\033[1;32m✅ Test " << test_count << " PASSED\\033[0m" << std::endl;
            }} else {{
                std::cout << "\\033[1;31m❌ Test " << test_count << " FAILED\\033[0m" << std::endl;
                SC_REPORT_ERROR("Comparator", "RM and RTL outputs mismatch!");
            }}
            rm_result.valid = false;
            rtl_result.valid = false;
        }}
    }}
}};

#endif // COMPARATOR_H
"""
    
    with open(output_path, 'w') as f:
        f.write(template)
    print(f"✅ Generated {output_path}")

if __name__ == "__main__":
    if len(sys.argv) != 5:
        print("Usage: python3 generate_verification.py <Vtop.h path> <transactor.h> <comparator.h> <output_struct.h>")
        sys.exit(1)
    
    vtop_path = sys.argv[1]
    transactor_path = sys.argv[2]
    comparator_path = sys.argv[3]
    output_struct_path = sys.argv[4]
    
    if not os.path.exists(vtop_path):
        print(f"Error: {vtop_path} not found!")
        sys.exit(1)
    
    ports = parse_vtop_header(vtop_path)
    inputs = [p for p in ports if p['direction'] == 'in' and p['name'] != 'clk']
    outputs = [p for p in ports if p['direction'] == 'out']
    
    print(f"Found {len(ports)} ports:")
    for p in ports:
        print(f"  - {p['name']} ({p['type']}) [{p['direction']}]")
    
    generate_output_struct(outputs, output_struct_path)
    generate_transactor(ports, transactor_path)
    generate_comparator(outputs, comparator_path)