// AUTO-GENERATED by generate_verification.py
// DO NOT EDIT MANUALLY

#ifndef COMPARATOR_H
#define COMPARATOR_H

#include <systemc>
#include <tlm>
#include <tlm_utils/simple_target_socket.h>
#include <map>
#include <set>
#include <vector>
#include <algorithm>
#include <string>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <cstdint>
#include "debug.h"
#include "output_struct.h"

using namespace sc_core;
using namespace tlm;
using namespace tlm_utils;

SC_MODULE(Comparator)
{
    simple_target_socket<Comparator> socket_rm;
    simple_target_socket<Comparator> socket_rtl;

    struct Result {
        OutputStruct output;
        bool valid = false;
    };
    
    Result rm_result;
    Result rtl_result;
    int test_count = 0;
    int passed_tests = 0;
    int failed_tests = 0;

    // Coverage data (100% dynamic - generated from Vtop.h)
    std::map<int64_t, int> cp_sum_bins;
    std::set<int64_t> cp_sum_unique_values;
    std::map<int64_t, int> cp_cout_bins;
    std::set<int64_t> cp_cout_unique_values;

    // Cross coverage (100% dynamic)
    std::map<std::pair<int64_t, int64_t>, int> cp_cross_sum_cout;

public:
    SC_CTOR(Comparator) 
        : socket_rm("socket_rm"), socket_rtl("socket_rtl")
    {
        socket_rm.register_b_transport(this, &Comparator::b_transport_rm);
        socket_rtl.register_b_transport(this, &Comparator::b_transport_rtl);
    }

    void b_transport_rm(tlm_generic_payload& trans, sc_time& delay)
    {
        if (trans.get_command() == TLM_WRITE_COMMAND) {
            auto* data = reinterpret_cast<OutputStruct*>(trans.get_data_ptr());
            rm_result.output = *data;
            rm_result.valid = true;
            check_and_compare();
        }
        trans.set_response_status(TLM_OK_RESPONSE);
    }

    void b_transport_rtl(tlm_generic_payload& trans, sc_time& delay)
    {
        if (trans.get_command() == TLM_WRITE_COMMAND) {
            auto* data = reinterpret_cast<OutputStruct*>(trans.get_data_ptr());
            rtl_result.output = *data;
            rtl_result.valid = true;
            check_and_compare();
        }
        trans.set_response_status(TLM_OK_RESPONSE);
    }

    void check_and_compare()
    {
        if (rm_result.valid && rtl_result.valid) {
            test_count++;
            bool match = true;
            if (rm_result.output.sum != rtl_result.output.sum) match = false;
            if (rm_result.output.cout != rtl_result.output.cout) match = false;
            if constexpr (DEBUG_CHECK_OUTPUTS) {
                std::cout << "\033[1;36m🔍 Test " << test_count << " Output Comparison:\033[0m" << std::endl;
                std::cout << "   RM:  " << "sum=" << rm_result.output.sum << ", " << "cout=" << rm_result.output.cout << std::endl;
                std::cout << "   RTL: " << "sum=" << rtl_result.output.sum << ", " << "cout=" << rtl_result.output.cout << std::endl;
            }

            if (match) {
                std::cout << "\033[1;32m✅ Test " << test_count << " PASSED\033[0m" << std::endl;
                passed_tests++;
                if constexpr (DEBUG_COVERAGE) {
                                cp_sum_bins[static_cast<int64_t>(rtl_result.output.sum)]++;
                                cp_sum_unique_values.insert(static_cast<int64_t>(rtl_result.output.sum));
                                cp_cout_bins[static_cast<int64_t>(rtl_result.output.cout)]++;
                                cp_cout_unique_values.insert(static_cast<int64_t>(rtl_result.output.cout));
                cp_cross_sum_cout[{static_cast<int64_t>(rtl_result.output.sum), static_cast<int64_t>(rtl_result.output.cout)}]++;
                }
            } else {
                std::cout << "\033[1;31m❌ Test " << test_count << " FAILED\033[0m" << std::endl;
                failed_tests++;
                // SC_REPORT_ERROR("Comparator", "RM and RTL outputs mismatch!");
            }
            rm_result.valid = false;
            rtl_result.valid = false;
        }
    }
    
    ~Comparator() {
        if constexpr (DEBUG_COVERAGE) {

            // Calculate total coverage percentage
            int total_coverage_points = 0;
            int covered_points = 0;
            total_coverage_points += passed_tests;  // One point per test per signal
            covered_points += cp_sum_unique_values.size();
            total_coverage_points += passed_tests;  // One point per test per signal
            covered_points += cp_cout_unique_values.size();
            total_coverage_points += passed_tests;  // One point per test per cross
            covered_points += cp_cross_sum_cout.size();

            double total_coverage_pct = (total_coverage_points > 0) ? (covered_points * 100.0 / total_coverage_points) : 0.0;
            if (total_coverage_pct > 100.0) total_coverage_pct = 100.0;
            
            // Generate terminal summary
            std::cout << "\033[1;35mTotal Functional Coverage: " 
                      << std::fixed << std::setprecision(1) << total_coverage_pct << "%\033[0m" << std::endl;
            std::cout << "Tests: " << passed_tests << " passed, " << failed_tests << " failed (" 
                      << (test_count > 0 ? (passed_tests * 100.0 / test_count) : 0.0) << "% pass rate)" << std::endl;
            
            // Write detailed report to coverage_report.log
            std::ofstream log_file("coverage_report.log");
            if (log_file.is_open()) {
                log_file << "========================================" << std::endl;
                log_file << "         DETAILED COVERAGE REPORT" << std::endl;
                log_file << "========================================" << std::endl;
                log_file << "Coverage Summary:" << std::endl;
                log_file << "  Total Coverage: " << std::fixed << std::setprecision(1) << total_coverage_pct << "%" << std::endl;
                log_file << "Tests Summary:" << std::endl;
                log_file << "  Total Tests: " << test_count << std::endl;
                log_file << "  Passed: " << passed_tests << std::endl;
                log_file << "  Failed: " << failed_tests << std::endl;
                log_file << "  Pass Rate: " << (test_count > 0 ? (passed_tests * 100.0 / test_count) : 0.0) << "%" << std::endl;
                log_file << std::endl;
                
                // Detailed coverage per signal
                log_file << "=== SIGNAL: SUM ===" << std::endl;
                log_file << "Unique Values: " << cp_sum_unique_values.size() << std::endl;
                log_file << "Hit Bins: " << cp_sum_bins.size() << std::endl;
                double cov_sum_pct = (passed_tests > 0) ? (cp_sum_unique_values.size() * 100.0 / passed_tests) : 0.0;
                if (cov_sum_pct > 100.0) cov_sum_pct = 100.0;
                log_file << "Coverage: " << std::fixed << std::setprecision(1) << cov_sum_pct << "%" << std::endl;
                // Top values
                std::vector<std::pair<int64_t, int>> sorted_sum(cp_sum_bins.begin(), cp_sum_bins.end());
                std::sort(sorted_sum.begin(), sorted_sum.end(), 
                         [](const std::pair<int64_t, int>& a, const std::pair<int64_t, int>& b) {
                             return a.second > b.second;
                         });
                log_file << "Top 3 Values: ";
                for (int i = 0; i < std::min(3, (int)sorted_sum.size()); i++) {
                    log_file << sorted_sum[i].first << "(" << sorted_sum[i].second << ") ";
                }
                log_file << std::endl << std::endl;
                log_file << "=== SIGNAL: COUT ===" << std::endl;
                log_file << "Unique Values: " << cp_cout_unique_values.size() << std::endl;
                log_file << "Hit Bins: " << cp_cout_bins.size() << std::endl;
                double cov_cout_pct = (passed_tests > 0) ? (cp_cout_unique_values.size() * 100.0 / passed_tests) : 0.0;
                if (cov_cout_pct > 100.0) cov_cout_pct = 100.0;
                log_file << "Coverage: " << std::fixed << std::setprecision(1) << cov_cout_pct << "%" << std::endl;
                // Top values
                std::vector<std::pair<int64_t, int>> sorted_cout(cp_cout_bins.begin(), cp_cout_bins.end());
                std::sort(sorted_cout.begin(), sorted_cout.end(), 
                         [](const std::pair<int64_t, int>& a, const std::pair<int64_t, int>& b) {
                             return a.second > b.second;
                         });
                log_file << "Top 3 Values: ";
                for (int i = 0; i < std::min(3, (int)sorted_cout.size()); i++) {
                    log_file << sorted_cout[i].first << "(" << sorted_cout[i].second << ") ";
                }
                log_file << std::endl << std::endl;
                log_file << "=== CROSS COVERAGE ===" << std::endl;
                double cov_cross_sum_cout_pct = (passed_tests > 0) ? (cp_cross_sum_cout.size() * 100.0 / passed_tests) : 0.0;
                if (cov_cross_sum_cout_pct > 100.0) cov_cross_sum_cout_pct = 100.0;
                log_file << "Cross sum x cout: " << std::fixed << std::setprecision(1) << cov_cross_sum_cout_pct << "%" << std::endl;
                log_file << "  Unique Combinations: " << cp_cross_sum_cout.size() << std::endl << std::endl;

                log_file << "========================================" << std::endl;
                log_file.close();
                std::cout << "\033[1;35m📋 Detailed coverage report written to coverage_report.log\033[0m" << std::endl;
            }

        }
    }
};

#endif // COMPARATOR_H
// AUTO-GENERATED by generate_verification.py
// DO NOT EDIT MANUALLY
#ifndef CUSTOM_DATA_H
#define CUSTOM_DATA_H

#include <vector>
#include <cstring>
#include <ostream>
#include <map>
#include <string>
#include <typeindex>
#include <cstdint>
#include <cstdlib>
#include <limits>
#include "rand_const.h"

// Macro to define fields and generate get_fields()
#define DECLARE_FIELD(name, type) type name;
#define ADD_FIELD_TO_MAP(name, type) \
    fields.emplace(#name, std::make_pair(offsetof(CustomData, name), std::type_index(typeid(type))));

// Define the input of the portlist here
#define DEFINE_CUSTOM_DATA_FIELDS \
    DECLARE_FIELD(a, bool) \
    DECLARE_FIELD(b, bool) \
    DECLARE_FIELD(cin, bool)

struct CustomData
{
    // Define fields using macro
    DEFINE_CUSTOM_DATA_FIELDS

    std::vector<unsigned char> serialize() const
    {
        std::vector<unsigned char> buffer(sizeof(*this));
        std::memcpy(buffer.data(), this, sizeof(*this));
        return buffer;
    }

    static CustomData deserialize(const unsigned char *buffer)
    {
        CustomData data;
        std::memcpy(&data, buffer, sizeof(CustomData));
        return data;
    }

    friend std::ostream &operator<<(std::ostream &os, const CustomData &data)
    {
        os << "{";
        bool first = true;
        auto fields = get_fields();
        for (const auto &field : fields)
        {
            if (!first)
                os << ", ";
            os << field.first << "=";
            auto offset = field.second.first;
            auto type = field.second.second;

            if (type == std::type_index(typeid(int16_t)))
            {
                os << *reinterpret_cast<const int16_t *>(reinterpret_cast<const char *>(&data) + offset);
            }
            else if (type == std::type_index(typeid(int32_t)))
            {
                os << *reinterpret_cast<const int32_t *>(reinterpret_cast<const char *>(&data) + offset);
            }
            else if (type == std::type_index(typeid(int64_t)))
            {
                os << *reinterpret_cast<const int64_t *>(reinterpret_cast<const char *>(&data) + offset);
            }
            else if (type == std::type_index(typeid(__int128)))
            {
                os << static_cast<int64_t>(*reinterpret_cast<const __int128 *>(reinterpret_cast<const char *>(&data) + offset));
            }
            else if (type == std::type_index(typeid(bool)))
            {
                os << (*reinterpret_cast<const bool *>(reinterpret_cast<const char *>(&data) + offset) ? "1" : "0");
            }
            first = false;
        }
        os << "}";
        return os;
    }

    static std::map<std::string, std::pair<size_t, std::type_index>> get_fields()
    {
        std::map<std::string, std::pair<size_t, std::type_index>> fields;
        // Generate field mappings using macro
        DEFINE_CUSTOM_DATA_FIELDS
#undef DECLARE_FIELD
#define DECLARE_FIELD(name, type) ADD_FIELD_TO_MAP(name, type)
        DEFINE_CUSTOM_DATA_FIELDS
#undef DECLARE_FIELD
        return fields;
    }

    static bool set_field(CustomData &data, const std::string &field_name, const std::string &value_str)
    {
        auto fields = get_fields();
        auto it = fields.find(field_name);
        if (it == fields.end())
            return false;

        size_t offset = it->second.first;
        std::type_index type = it->second.second;

        // Handle "rand" first
        if (value_str == "\"rand\"" || value_str == "rand")
        {
            double min_val = 0;
            double max_val = 0;

            if (type == std::type_index(typeid(int16_t)))
            {
                min_val = std::numeric_limits<int16_t>::min();
                max_val = std::numeric_limits<int16_t>::max();
            }
            else if (type == std::type_index(typeid(int32_t)))
            {
                min_val = std::numeric_limits<int32_t>::min();
                max_val = std::numeric_limits<int32_t>::max();
            }
            else if (type == std::type_index(typeid(int64_t)))
            {
                min_val = std::numeric_limits<int64_t>::min();
                max_val = std::numeric_limits<int64_t>::max();
            }
            else if (type == std::type_index(typeid(__int128)))
            {
                min_val = static_cast<double>(std::numeric_limits<__int128>::min());
                max_val = static_cast<double>(std::numeric_limits<__int128>::max());
            }
            else if (type == std::type_index(typeid(bool)))
            {
                // For bool, rand means random true/false
                *reinterpret_cast<bool *>(reinterpret_cast<char *>(&data) + offset) = (std::rand() % 2 == 0);
                return true;
            }

            // Apply constraints if available
            if (RandConstraints::constraints.find(field_name) != RandConstraints::constraints.end())
            {
                min_val = RandConstraints::constraints.at(field_name).first;
                max_val = RandConstraints::constraints.at(field_name).second;
            }

            long long range = static_cast<long long>(max_val - min_val + 1);
            long long rand_val = min_val + (std::rand() % range);

            if (type == std::type_index(typeid(int16_t)))
            {
                *reinterpret_cast<int16_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int16_t>(rand_val);
            }
            else if (type == std::type_index(typeid(int32_t)))
            {
                *reinterpret_cast<int32_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int32_t>(rand_val);
            }
            else if (type == std::type_index(typeid(int64_t)))
            {
                *reinterpret_cast<int64_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int64_t>(rand_val);
            }
            else if (type == std::type_index(typeid(__int128)))
            {
                *reinterpret_cast<__int128 *>(reinterpret_cast<char *>(&data) + offset) = static_cast<__int128>(rand_val);
            }
            return true;
        }

        // Handle boolean values
        if (type == std::type_index(typeid(bool)))
        {
            std::string value = value_str;
            // Remove surrounding quotes if present (e.g., "\"true\"" → "true")
            if (value.size() >= 2 && value.front() == '\"' && value.back() == '\"')
            {
                value = value.substr(1, value.size() - 2);
            }
            if (value == "true" || value == "1")
            {
                *reinterpret_cast<bool *>(reinterpret_cast<char *>(&data) + offset) = true;
                return true;
            }
            else if (value == "false" || value == "0")
            {
                *reinterpret_cast<bool *>(reinterpret_cast<char *>(&data) + offset) = false;
                return true;
            }
            return false; // Invalid boolean string
        }

        // Handle numeric values
        try
        {
            if (type == std::type_index(typeid(int16_t)))
            {
                *reinterpret_cast<int16_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int16_t>(std::stoi(value_str));
            }
            else if (type == std::type_index(typeid(int32_t)))
            {
                *reinterpret_cast<int32_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int32_t>(std::stoll(value_str));
            }
            else if (type == std::type_index(typeid(int64_t)))
            {
                *reinterpret_cast<int64_t *>(reinterpret_cast<char *>(&data) + offset) = std::stoll(value_str);
            }
            else if (type == std::type_index(typeid(__int128)))
            {
                *reinterpret_cast<__int128 *>(reinterpret_cast<char *>(&data) + offset) = std::stoll(value_str);
            }
            else
            {
                return false; // Unsupported type
            }
            return true;
        }
        catch (...)
        {
            return false;
        }
    }
};

#endif // CUSTOM_DATA_H
// debug.h
#ifndef DEBUG_H
#define DEBUG_H

// Set to true to enable debug prints
constexpr bool DEBUG_RM = true;
constexpr bool DEBUG_TLM = false;
constexpr bool DEBUG_RTL = true;
constexpr bool DEBUG_CHECK_OUTPUTS = true;
constexpr bool DEBUG_COVERAGE = true;

#endif // DEBUG_H
// driver.h (updated)
#ifndef INITIATOR_H
#define INITIATOR_H

#include <systemc>
#include <tlm>
#include <tlm_utils/simple_initiator_socket.h>
#include "custom_data.h"
#include "debug.h"
#include <iostream>

SC_MODULE(Driver)
{
    // Two initiator sockets: one for RM, one for Transactor
    tlm_utils::simple_initiator_socket<Driver> socket_rm;
    tlm_utils::simple_initiator_socket<Driver> socket_transactor;

    sc_core::sc_fifo_in<CustomData> in;

    SC_CTOR(Driver) : socket_rm("socket_rm"), socket_transactor("socket_transactor")
    {
        SC_THREAD(process);
    }

    void process()
    {
        while (true)
        {
            CustomData data = in.read();
            auto buffer = data.serialize();

            // Prepare transaction (we'll reuse the same payload for both)
            tlm::tlm_generic_payload trans;
            trans.set_data_ptr(buffer.data());
            trans.set_data_length(buffer.size());
            trans.set_command(tlm::TLM_WRITE_COMMAND);
            trans.set_streaming_width(buffer.size());
            trans.set_byte_enable_ptr(nullptr);
            trans.set_dmi_allowed(false);
            trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);

            sc_core::sc_time delay_rm = sc_core::SC_ZERO_TIME;
            sc_core::sc_time delay_trans = sc_core::SC_ZERO_TIME;

            if constexpr (DEBUG_TLM)
            {
                std::cout << sc_core::sc_time_stamp() << " |   Driver   | TLM | Driving:  " << data << std::endl;
            }

            // Send to RM
            socket_rm->b_transport(trans, delay_rm);
            if (trans.is_response_error())
            {
                SC_REPORT_ERROR("Driver", "Write to RM failed");
            }

            // Reset response status for second transaction (good practice)
            trans.set_response_status(tlm::TLM_INCOMPLETE_RESPONSE);

            // Send to Transactor
            socket_transactor->b_transport(trans, delay_trans);
            if (trans.is_response_error())
            {
                SC_REPORT_ERROR("Driver", "Write to Transactor failed");
            }

            std::cout << "\033[1;32m=======================\033[0m" << "\033[1;34m Test Finished \033[0m" << "\033[1;32m========================\033[0m" << std::endl;

        }
    }
};

#endif // INITIATOR_H// AUTO-GENERATED by generate_verification.py
// DO NOT EDIT MANUALLY

#ifndef OUTPUT_STRUCT_H
#define OUTPUT_STRUCT_H

struct OutputStruct {
    bool sum;
    bool cout;
};

#endif // OUTPUT_STRUCT_H
// AUTO-GENERATED by generate_rand_const.py
// DO NOT EDIT MANUALLY

#ifndef RAND_CONST_H
#define RAND_CONST_H

#include <map>
#include <string>
#include <utility> // for std::pair

struct RandConstraints {
    // Declaration only
    static std::map<std::string, std::pair<double, double>> constraints;
};

#endif // RAND_CONST_H
#ifndef TARGET_H
#define TARGET_H

#include <systemc>
#include <tlm>
#include <tlm_utils/simple_initiator_socket.h>
#include <tlm_utils/simple_target_socket.h>
#include "custom_data.h"
#include "output_struct.h"
#include "debug.h"

#include <iostream> // for coloring

using namespace tlm_utils;
using namespace tlm;
using namespace sc_core;
using namespace std;

SC_MODULE(RM)
{
    simple_target_socket<RM> socket;
    simple_initiator_socket<RM> socket_comparator; // New socket

    SC_CTOR(RM) : socket("socket"), socket_comparator("socket_comparator")
    {
        socket.register_b_transport(this, &RM::b_transport);
    }

    void b_transport(tlm_generic_payload & trans, sc_time & delay)
    {
        if (trans.get_command() == tlm::TLM_IGNORE_COMMAND)
        {
            trans.set_response_status(tlm::TLM_OK_RESPONSE);
            return;
        }
        auto *buffer = trans.get_data_ptr();
        auto data = CustomData::deserialize(buffer);

        if constexpr (DEBUG_TLM)
        {
            std::cout << sc_time_stamp() << " |     RM     | TLM | Received: " << data << std::endl;
        }

        trans.set_response_status(tlm::TLM_OK_RESPONSE);
        
        // 🔴 DUMMY REFERENCE MODEL - AUTO-GENERATED 🔴
        // This is a placeholder RM. Replace with actual logic!
        
        // Initialize dummy outputs (dynamically generated from OutputStruct)
        bool sum = 0;
        bool cout = 0;

        OutputStruct output;
        output.sum = sum;
        output.cout = cout;
        send_to_comparator(output);
    } 

    void send_to_comparator(const OutputStruct &output);
};

#endif
#ifndef STIMULATOR_H
#define STIMULATOR_H

#include <systemc>
#include <tlm>
#include <fstream>
#include <sstream>
#include <string>
#include <cstdlib>
#include <ctime>
#include <limits>
#include <map>
#include <vector>
#include "custom_data.h"
#include "rand_const.h"
#include "debug.h"
#include "timing_controller.h"

using namespace sc_core;
using namespace std;

SC_MODULE(Stimulator)
{
    TimingController *tc = nullptr; // ← Initialize to nullptr

    sc_core::sc_fifo_out<CustomData> out;
    std::string json_file;

    SC_CTOR(Stimulator) : out("out"), json_file("stimuli.json")
    {
        SC_THREAD(generate);
    }

    void set_timing_controller(TimingController * controller)
    {
        tc = controller;
    }

    void set_params(const std::string &file)
    {
        json_file = file;
    }

    void generate()
    {
        std::srand(std::time(NULL));
        std::ifstream file(json_file);
        if (!file)
        {
            SC_REPORT_ERROR("Stimulator", ("Cannot open " + json_file).c_str());
            return;
        }
        std::stringstream ss;
        ss << file.rdbuf();
        std::string json = ss.str();

        // Find tests array
        size_t pos = json.find("\"tests\"");
        if (pos == std::string::npos)
        {
            SC_REPORT_ERROR("Stimulator", "JSON must contain 'tests' array");
            return;
        }
        pos = json.find('[', pos);
        if (pos == std::string::npos)
        {
            SC_REPORT_ERROR("Stimulator", "Invalid 'tests' array");
            return;
        }

        // Count test cases
        size_t test_count = 0;
        size_t count_pos = pos + 1;
        int brace_count = 0;
        bool in_object = false;
        while (count_pos < json.length())
        {
            if (json[count_pos] == '{')
            {
                in_object = true;
                brace_count++;
            }
            else if (json[count_pos] == '}')
            {
                brace_count--;
                if (brace_count == 0 && in_object)
                {
                    test_count++;
                    in_object = false;
                }
            }
            count_pos++;
            if (brace_count == 0 && json[count_pos] == ']')
                break;
        }

        // Parse and send each test case
        size_t sent_count = 0;
        pos = pos + 1; // Move past '['
        while (sent_count < test_count && pos < json.length())
        {
            // Skip whitespace and commas
            while (pos < json.length() && (json[pos] == ' ' || json[pos] == '\n' || json[pos] == '\r' || json[pos] == '\t' || json[pos] == ','))
            {
                pos++;
            }
            if (pos >= json.length() || json[pos] != '{')
                break;

            CustomData data{};
            // Find end of object
            size_t end = pos;
            brace_count = 1;
            while (end < json.length() && brace_count > 0)
            {
                end++;
                if (json[end] == '{')
                    brace_count++;
                else if (json[end] == '}')
                    brace_count--;
            }
            if (brace_count != 0 || end >= json.length())
            {
                SC_REPORT_WARNING("Stimulator", "Invalid JSON object detected");
                break;
            }
            std::string test = json.substr(pos, end - pos + 1);

            // Parse all key-value pairs
            std::map<std::string, std::string> fields;
            size_t field_pos = test.find('"', 0);
            while (field_pos != std::string::npos && field_pos < test.length())
            {
                size_t key_end = test.find('"', field_pos + 1);
                if (key_end == std::string::npos)
                    break;
                std::string key = test.substr(field_pos + 1, key_end - field_pos - 1);
                size_t val_start = test.find(':', key_end) + 1;
                size_t val_end = test.find_first_of(",}", val_start);
                std::string value = test.substr(val_start, val_end - val_start);
                value.erase(0, value.find_first_not_of(" \n\r\t"));
                value.erase(value.find_last_not_of(" \n\r\t") + 1);
                fields[key] = value;
                field_pos = test.find('"', val_end);
            }

            // Map fields to CustomData dynamically
            bool valid = true;
            for (const auto &field : CustomData::get_fields())
            {
                if (fields.find(field.first) != fields.end())
                {
                    if (!CustomData::set_field(data, field.first, fields[field.first]))
                    {
                        valid = false;
                        break;
                    }
                }
            }
            if (valid)
            {
                wait(SC_ZERO_TIME);
                out.write(data);
                if constexpr (DEBUG_RTL || DEBUG_RM || DEBUG_TLM)
                {
                    if constexpr (DEBUG_TLM)
                    {
                        cout << "\n\033[1;32m======================= TLM Job Start =========================\033[0m" << endl;
                        std::cout << sc_time_stamp() << " | Stimulator | TLM | Pulled:   " << data << std::endl;
                    } else{
                        cout << "\n\033[1;32m======================= Test Case =========================\033[0m" << endl;
                        std::cout << sc_time_stamp() << " | Stimulator | TLM | Pulled:   " << data << std::endl;
                    }
                }
                sent_count++;
                wait(tc->next_stimulus_event);
            }
            else
            {
                SC_REPORT_WARNING("Stimulator", ("Failed to parse test case " + std::to_string(sent_count + 1)).c_str());
            }
            pos = end + 1;
        }

        // Wait for Driver and RM to process all FIFO entries
        sc_core::wait(sent_count * 2, sc_core::SC_NS); // Conservative delay based on test cases

        // Stop simulation after all test cases
        if (sent_count == test_count)
        {
            std::cout << "All Cases Are Tested" << std::endl;
            sc_core::sc_stop();
        }
        else
        {
            SC_REPORT_WARNING("Stimulator", ("Only " + std::to_string(sent_count) + " of " + std::to_string(test_count) + " test cases sent").c_str());
            sc_core::sc_stop();
        }
    }
};

#endif// timing_controller.h
#ifndef TIMING_CONTROLLER_H
#define TIMING_CONTROLLER_H

#include <systemc>

SC_MODULE(TimingController)
{
    // ⚙️ Centralized timing configuration
    const sc_core::sc_time CLOCK_PERIOD = sc_core::sc_time(5, sc_core::SC_NS); // ← Clock period
    const double CLOCK_DUTY_CYCLE = 0.5;       // 50%
    const sc_core::sc_time CLOCK_START_DELAY = sc_core::sc_time(0, sc_core::SC_NS);
    const bool CLOCK_POSITIVE_PULSE = true;

    const int OUTPUT_DELAY_CYCLES = 2;         // Cycles to wait for RTL output
    const sc_core::sc_time STIMULUS_INTERVAL = sc_core::sc_time(10, sc_core::SC_NS);

    // Events
    sc_core::sc_event inputs_ready_event;
    sc_core::sc_event outputs_ready_event;
    sc_core::sc_event next_stimulus_event;

    // Public clock signal (so Transactor can use it)
    sc_core::sc_clock clk;

    SC_CTOR(TimingController)
        : clk("global_clk", CLOCK_PERIOD, CLOCK_DUTY_CYCLE, CLOCK_START_DELAY, CLOCK_POSITIVE_PULSE)
    {
        SC_THREAD(stimulus_scheduler);
        SC_THREAD(rtl_output_scheduler);
    }

    void stimulus_scheduler()
    {
        while (true) {
            next_stimulus_event.notify(STIMULUS_INTERVAL);
            wait(next_stimulus_event);
        }
    }

    void rtl_output_scheduler()
    {
        while (true) {
            wait(inputs_ready_event);
            wait(OUTPUT_DELAY_CYCLES * CLOCK_PERIOD); // Scale with clock
            outputs_ready_event.notify();
        }
    }
};

#endif // TIMING_CONTROLLER_H// AUTO-GENERATED by generate_verification.py
// DO NOT EDIT MANUALLY

#ifndef TRANSACTOR_H
#define TRANSACTOR_H

#include <systemc>
#include <tlm>
#include <tlm_utils/simple_target_socket.h>
#include <iostream>  //
#include "custom_data.h"
#include "debug.h"
#include "verilated/obj_dir/Vtop.h"
#include "timing_controller.h"
#include "comparator.h"
#include "output_struct.h"

using namespace std;  //
using namespace sc_core;

SC_MODULE(Transactor)
{
    tlm_utils::simple_target_socket<Transactor> socket;
    tlm_utils::simple_initiator_socket<Transactor> socket_comparator;
    Vtop* rtl = nullptr;
    TimingController* tc = nullptr;

    // Auto-generated signals
    sc_core::sc_signal<bool> a_sig;
    sc_core::sc_signal<bool> b_sig;
    sc_core::sc_signal<bool> cin_sig;
    sc_core::sc_signal<bool> sum_sig;
    sc_core::sc_signal<bool> cout_sig;

    SC_CTOR(Transactor) : socket_comparator("socket_comparator")
    {
        socket.register_b_transport(this, &Transactor::b_transport);
    }

    void set_timing_controller(TimingController* controller) {
        if (tc != nullptr) {
            SC_REPORT_ERROR("Transactor", "Timing controller already set!");
            return;
        }
        tc = controller;
        rtl = new Vtop("rtl");
        rtl-> a(a_sig);
        rtl-> b(b_sig);
        rtl-> cin(cin_sig);
        rtl-> sum(sum_sig);
        rtl-> cout(cout_sig);
    }

    void b_transport(tlm::tlm_generic_payload& trans, sc_core::sc_time& delay)
    {
        if (trans.get_command() == tlm::TLM_WRITE_COMMAND)
        {
            if (rtl == nullptr) {
                SC_REPORT_ERROR("Transactor", "RTL not initialized!");
                return;
            }

            auto data = CustomData::deserialize(trans.get_data_ptr());
            a_sig.write(static_cast<bool>(data.a));
            b_sig.write(static_cast<bool>(data.b));
            cin_sig.write(static_cast<bool>(data.cin));

            if constexpr (DEBUG_TLM) {
                cout << "\n\033[1;31mIIIII===================  Inside Transactor  ====================IIIII\033[0m" << endl;
                std::cout << "\033[1;31m"
                          << sc_time_stamp()
                          << " | Transactor | TLM | Driving RTL..."
                          << data
                          << "\033[0m" << endl;
            }

            tc->inputs_ready_event.notify();
            wait(tc->outputs_ready_event);
            bool sum = sum_sig.read();
            bool cout = cout_sig.read();
        // Send all outputs to comparator
        OutputStruct output;
    output.sum = static_cast<int32_t>(sum);
    output.cout = static_cast<int32_t>(cout);
        send_to_comparator(output);

            if constexpr (DEBUG_RTL) {
                std::cout << "\033[1;31m"
                          << sc_time_stamp()
                          << " | Transactor | RTL Outputs:"                          << " | sum = " << sum                          << " | cout = " << cout
                          << "\033[0m" << endl;
                cout << "\033[1;31mIIIII===================  RTL Process Completed  ====================IIIII\033[0m\n"
                     << endl;
            }
        }
        trans.set_response_status(tlm::TLM_OK_RESPONSE);
    }

    void send_to_comparator(const OutputStruct& output)
    {
        tlm_generic_payload trans;
        sc_time delay = SC_ZERO_TIME;
        trans.set_data_ptr(reinterpret_cast<unsigned char*>(const_cast<OutputStruct*>(&output)));
        trans.set_data_length(sizeof(OutputStruct));
        trans.set_command(TLM_WRITE_COMMAND);
        trans.set_response_status(TLM_INCOMPLETE_RESPONSE);
        socket_comparator->b_transport(trans, delay);
    }

    ~Transactor() {
        delete rtl;
    }
};

#endif // TRANSACTOR_H
// main.cpp (updated)
#include <systemc>
#include <tlm_utils/simple_initiator_socket.h>
#include <tlm_utils/simple_target_socket.h>
#include "stimulator.h"
#include "driver.h"
#include "rm.h"
#include "transactor.h"
#include "comparator.h" // Add this


int sc_main(int argc, char *argv[])
{
    sc_core::sc_report_handler::set_actions("/IEEE_Std_1666/deprecated", sc_core::SC_DO_NOTHING);
    std::string json_file = (argc > 1) ? argv[1] : "stimule/stimuli_big_alu.json";

    TimingController tc("timing_controller");

    Stimulator stim("stim");
    stim.set_params(json_file);
    stim.set_timing_controller(&tc);

    Driver driver("driver");
    RM rm("rm");
    Transactor transactor("transactor");
    Comparator comparator("comparator"); // New module

    transactor.set_timing_controller(&tc);

    sc_core::sc_fifo<CustomData> fifo;
    stim.out(fifo);
    driver.in(fifo);

    // Bind sockets
    driver.socket_rm.bind(rm.socket);
    driver.socket_transactor.bind(transactor.socket);
    
    // Bind comparator sockets
    rm.socket_comparator.bind(comparator.socket_rm);
    transactor.socket_comparator.bind(comparator.socket_rtl);


    sc_core::sc_start();
    return 0;
}// AUTO-GENERATED by generate_rand_const.py
// DO NOT EDIT MANUALLY

#include "rand_const.h"

// Definition: only once in the entire program
std::map<std::string, std::pair<double, double>> RandConstraints::constraints = {
    {"a", {0, 1}},
    {"b", {0, 1}},
    {"cin", {0, 1}}
};
// file: rm.cpp
// 🔴 DUMMY REFERENCE MODEL - AUTO-GENERATED 🔴
// This is a placeholder RM. Replace with actual logic!

#include "rm.h"

void RM::send_to_comparator(const OutputStruct &output)
{
    tlm_generic_payload trans;
    sc_time delay = SC_ZERO_TIME;
    trans.set_data_ptr(reinterpret_cast<unsigned char *>(const_cast<OutputStruct *>(&output)));
    trans.set_data_length(sizeof(OutputStruct));
    trans.set_command(TLM_WRITE_COMMAND);
    trans.set_response_status(TLM_INCOMPLETE_RESPONSE);
    socket_comparator->b_transport(trans, delay);
}
