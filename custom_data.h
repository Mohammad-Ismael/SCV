// AUTO-GENERATED by generate_verification.py
// DO NOT EDIT MANUALLY
#ifndef CUSTOM_DATA_H
#define CUSTOM_DATA_H

#include <vector>
#include <cstring>
#include <ostream>
#include <map>
#include <string>
#include <typeindex>
#include <cstdint>
#include <cstdlib>
#include <limits>
#include "rand_const.h"

// Macro to define fields and generate get_fields()
#define DECLARE_FIELD(name, type) type name;
#define ADD_FIELD_TO_MAP(name, type) \
    fields.emplace(#name, std::make_pair(offsetof(CustomData, name), std::type_index(typeid(type))));

// Define the input of the portlist here
#define DEFINE_CUSTOM_DATA_FIELDS \


struct CustomData
{
    // Define fields using macro
    DEFINE_CUSTOM_DATA_FIELDS

    std::vector<unsigned char> serialize() const
    {
        std::vector<unsigned char> buffer(sizeof(*this));
        std::memcpy(buffer.data(), this, sizeof(*this));
        return buffer;
    }

    static CustomData deserialize(const unsigned char *buffer)
    {
        CustomData data;
        std::memcpy(&data, buffer, sizeof(CustomData));
        return data;
    }

    friend std::ostream &operator<<(std::ostream &os, const CustomData &data)
    {
        os << "{";
        bool first = true;
        auto fields = get_fields();
        for (const auto &field : fields)
        {
            if (!first)
                os << ", ";
            os << field.first << "=";
            auto offset = field.second.first;
            auto type = field.second.second;

            if (type == std::type_index(typeid(int16_t)))
            {
                os << *reinterpret_cast<const int16_t *>(reinterpret_cast<const char *>(&data) + offset);
            }
            else if (type == std::type_index(typeid(int32_t)))
            {
                os << *reinterpret_cast<const int32_t *>(reinterpret_cast<const char *>(&data) + offset);
            }
            else if (type == std::type_index(typeid(int64_t)))
            {
                os << *reinterpret_cast<const int64_t *>(reinterpret_cast<const char *>(&data) + offset);
            }
            else if (type == std::type_index(typeid(__int128)))
            {
                os << static_cast<int64_t>(*reinterpret_cast<const __int128 *>(reinterpret_cast<const char *>(&data) + offset));
            }
            else if (type == std::type_index(typeid(bool)))
            {
                os << (*reinterpret_cast<const bool *>(reinterpret_cast<const char *>(&data) + offset) ? "1" : "0");
            }
            first = false;
        }
        os << "}";
        return os;
    }

    static std::map<std::string, std::pair<size_t, std::type_index>> get_fields()
    {
        std::map<std::string, std::pair<size_t, std::type_index>> fields;
        // Generate field mappings using macro
        DEFINE_CUSTOM_DATA_FIELDS
#undef DECLARE_FIELD
#define DECLARE_FIELD(name, type) ADD_FIELD_TO_MAP(name, type)
        DEFINE_CUSTOM_DATA_FIELDS
#undef DECLARE_FIELD
        return fields;
    }

    static bool set_field(CustomData &data, const std::string &field_name, const std::string &value_str)
    {
        auto fields = get_fields();
        auto it = fields.find(field_name);
        if (it == fields.end())
            return false;

        size_t offset = it->second.first;
        std::type_index type = it->second.second;

        // Handle "rand" first
        if (value_str == "\"rand\"" || value_str == "rand")
        {
            double min_val = 0;
            double max_val = 0;

            if (type == std::type_index(typeid(int16_t)))
            {
                min_val = std::numeric_limits<int16_t>::min();
                max_val = std::numeric_limits<int16_t>::max();
            }
            else if (type == std::type_index(typeid(int32_t)))
            {
                min_val = std::numeric_limits<int32_t>::min();
                max_val = std::numeric_limits<int32_t>::max();
            }
            else if (type == std::type_index(typeid(int64_t)))
            {
                min_val = std::numeric_limits<int64_t>::min();
                max_val = std::numeric_limits<int64_t>::max();
            }
            else if (type == std::type_index(typeid(__int128)))
            {
                min_val = static_cast<double>(std::numeric_limits<__int128>::min());
                max_val = static_cast<double>(std::numeric_limits<__int128>::max());
            }
            else if (type == std::type_index(typeid(bool)))
            {
                // For bool, rand means random true/false
                *reinterpret_cast<bool *>(reinterpret_cast<char *>(&data) + offset) = (std::rand() % 2 == 0);
                return true;
            }

            // Apply constraints if available
            if (RandConstraints::constraints.find(field_name) != RandConstraints::constraints.end())
            {
                min_val = RandConstraints::constraints.at(field_name).first;
                max_val = RandConstraints::constraints.at(field_name).second;
            }

            long long range = static_cast<long long>(max_val - min_val + 1);
            long long rand_val = min_val + (std::rand() % range);

            if (type == std::type_index(typeid(int16_t)))
            {
                *reinterpret_cast<int16_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int16_t>(rand_val);
            }
            else if (type == std::type_index(typeid(int32_t)))
            {
                *reinterpret_cast<int32_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int32_t>(rand_val);
            }
            else if (type == std::type_index(typeid(int64_t)))
            {
                *reinterpret_cast<int64_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int64_t>(rand_val);
            }
            else if (type == std::type_index(typeid(__int128)))
            {
                *reinterpret_cast<__int128 *>(reinterpret_cast<char *>(&data) + offset) = static_cast<__int128>(rand_val);
            }
            return true;
        }

        // Handle boolean values
        if (type == std::type_index(typeid(bool)))
        {
            std::string value = value_str;
            // Remove surrounding quotes if present (e.g., "\"true\"" â†’ "true")
            if (value.size() >= 2 && value.front() == '\"' && value.back() == '\"')
            {
                value = value.substr(1, value.size() - 2);
            }
            if (value == "true" || value == "1")
            {
                *reinterpret_cast<bool *>(reinterpret_cast<char *>(&data) + offset) = true;
                return true;
            }
            else if (value == "false" || value == "0")
            {
                *reinterpret_cast<bool *>(reinterpret_cast<char *>(&data) + offset) = false;
                return true;
            }
            return false; // Invalid boolean string
        }

        // Handle numeric values
        try
        {
            if (type == std::type_index(typeid(int16_t)))
            {
                *reinterpret_cast<int16_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int16_t>(std::stoi(value_str));
            }
            else if (type == std::type_index(typeid(int32_t)))
            {
                *reinterpret_cast<int32_t *>(reinterpret_cast<char *>(&data) + offset) = static_cast<int32_t>(std::stoll(value_str));
            }
            else if (type == std::type_index(typeid(int64_t)))
            {
                *reinterpret_cast<int64_t *>(reinterpret_cast<char *>(&data) + offset) = std::stoll(value_str);
            }
            else if (type == std::type_index(typeid(__int128)))
            {
                *reinterpret_cast<__int128 *>(reinterpret_cast<char *>(&data) + offset) = std::stoll(value_str);
            }
            else
            {
                return false; // Unsupported type
            }
            return true;
        }
        catch (...)
        {
            return false;
        }
    }
};

#endif // CUSTOM_DATA_H
