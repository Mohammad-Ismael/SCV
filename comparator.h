// AUTO-GENERATED by generate_verification.py
// DO NOT EDIT MANUALLY

#ifndef COMPARATOR_H
#define COMPARATOR_H

#include <systemc>
#include <tlm>
#include <tlm_utils/simple_target_socket.h>
#include <map>
#include <set>
#include <vector>
#include <algorithm>
#include <string>
#include <fstream>
#include <sstream>
#include <iomanip>
#include <cstdint>
#include "debug.h"
#include "output_struct.h"

using namespace sc_core;
using namespace tlm;
using namespace tlm_utils;

SC_MODULE(Comparator)
{
    simple_target_socket<Comparator> socket_rm;
    simple_target_socket<Comparator> socket_rtl;

    struct Result {
        OutputStruct output;
        bool valid = false;
    };
    
    Result rm_result;
    Result rtl_result;
    int test_count = 0;
    int passed_tests = 0;
    int failed_tests = 0;

    // Coverage data (100% dynamic - generated from Vtop.h)
    // No output ports

    // Cross coverage (100% dynamic)


public:
    SC_CTOR(Comparator) 
        : socket_rm("socket_rm"), socket_rtl("socket_rtl")
    {
        socket_rm.register_b_transport(this, &Comparator::b_transport_rm);
        socket_rtl.register_b_transport(this, &Comparator::b_transport_rtl);
    }

    void b_transport_rm(tlm_generic_payload& trans, sc_time& delay)
    {
        if (trans.get_command() == TLM_WRITE_COMMAND) {
            auto* data = reinterpret_cast<OutputStruct*>(trans.get_data_ptr());
            rm_result.output = *data;
            rm_result.valid = true;
            check_and_compare();
        }
        trans.set_response_status(TLM_OK_RESPONSE);
    }

    void b_transport_rtl(tlm_generic_payload& trans, sc_time& delay)
    {
        if (trans.get_command() == TLM_WRITE_COMMAND) {
            auto* data = reinterpret_cast<OutputStruct*>(trans.get_data_ptr());
            rtl_result.output = *data;
            rtl_result.valid = true;
            check_and_compare();
        }
        trans.set_response_status(TLM_OK_RESPONSE);
    }

    void check_and_compare()
    {
        if (rm_result.valid && rtl_result.valid) {
            test_count++;
            bool match = true;
            if (rm_result.output.value != rtl_result.output.value) match = false;
            if constexpr (DEBUG_CHECK_OUTPUTS) {
                std::cout << "\033[1;36mðŸ” Test " << test_count << " Output Comparison:\033[0m" << std::endl;
                std::cout << "   RM:  " << rm_result.output.value << std::endl;
                std::cout << "   RTL: " << rtl_result.output.value << std::endl;
            }

            if (match) {
                std::cout << "\033[1;32mâœ… Test " << test_count << " PASSED\033[0m" << std::endl;
                passed_tests++;
                if constexpr (DEBUG_COVERAGE) {


                }
            } else {
                std::cout << "\033[1;31mâŒ Test " << test_count << " FAILED\033[0m" << std::endl;
                failed_tests++;
                // SC_REPORT_ERROR("Comparator", "RM and RTL outputs mismatch!");
            }
            rm_result.valid = false;
            rtl_result.valid = false;
        }
    }
    
    ~Comparator() {
        if constexpr (DEBUG_COVERAGE) {

            std::cout << "\033[1;35mTotal Functional Coverage: 0.0%\033[0m" << std::endl;
            std::cout << "Tests: " << passed_tests << " passed, " << failed_tests << " failed (" 
                      << (test_count > 0 ? (passed_tests * 100.0 / test_count) : 0.0) << "% pass rate)" << std::endl;

        }
    }
};

#endif // COMPARATOR_H
